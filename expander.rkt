;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#lang br/quicklang

(provide (rename-out [golfscript-module-begin #%module-begin]))
(provide (matching-identifiers-out #rx"^gs-" (all-defined-out)))

;;; Rquires for gs-~ definition.
(require golfscript/parser golfscript/tokenizer brag/support)

;;; Global data and data types.
(define stack empty)
(define globals (make-hash))
(define builtins (make-hash))
(define undefined-var 'undefined)
(struct stack-mark (id))

;; For eval we need a namespace anchor.
(define-namespace-anchor gs)
(define gs-namespace (namespace-anchor->namespace gs))

;;; Module begin.
(define-macro (golfscript-module-begin PROGRAM)
  #'(#%module-begin
     PROGRAM))

;;; Syntax
(define-macro (gs-program EXPR ...)
  ;; Vars are self-evaluating so all we need to do is display the stack.
  (syntax/loc caller-stx
    (begin
      EXPR ...
      (gs-display-stack))))

(define-macro (gs-var VAR)
  (syntax/loc caller-stx (gs-val VAR)))

(define-macro (gs-string STRING)
  (syntax/loc caller-stx (gs-push! STRING)))

(define-macro (gs-block EXPR ...)
  (syntax/loc caller-stx (gs-push! (lambda () EXPR ...))))

(define-macro (gs-list EXPR ...)
  ;; Mark stack position, and pop everything between it and top of stack.
  (syntax/loc caller-stx
    (let ([mymark (gensym)])
      (gs-push! (stack-mark mymark))
      EXPR ...
      ;; Pop until we reach mymark.
      (let ([top (gs-pop! #:return-stack-mark? #t)]
            [return-list empty])
        (until (and (stack-mark? top) (equal? (stack-mark-id top) mymark))
               (set! return-list (cons top return-list))
               (set! top (gs-pop! #:return-stack-mark? #t)))
        (gs-push! return-list)
        ))))

(define-macro (gs-assignment EXPR (gs-var VAR))
  (syntax/loc caller-stx
    (begin
      EXPR
      (let ([value (gs-pop!)])
        (hash-set! globals VAR value)
        (gs-push! value)))))

(define-macro (gs-comment COMMENT)
  #'(void))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Internal functions generated by syntax macros.
(define (gs-display-stack)
  (display stack))

(define (gs-val a-var)
  (let ([value (hash-ref globals a-var 'undefined)])
    (cond
      [(procedure? value) (value)]
      ;; Numbers have their literal value as their default value.
      [(number? a-var) (gs-push! a-var)]
      ;; Undefined variables may have a default builtin value.
      [(and (equal? 'undefined value) (gs-builtin? a-var)) (gs-builtin! a-var)]
      ;; Undefined values are ignored. Otherwise we push the new vlaue to the stack.
      [(not (equal? 'undefined value)) (gs-push! value)]
      )))

(define (stack-height) (length stack))

(define (gs-push! value)
  (display "gs-push! ")
  (writeln value)
  (set! stack (cons value stack)))

(define (gs-pop! #:return-stack-mark? [return-stack-mark? #f])
  (display "gs-pop! stack")
  (writeln stack)
  (if return-stack-mark?
      (let ([top (first stack)])
        (set! stack (rest stack))
        top)
      (let ([top (first stack)]
            [found-stack-marks empty])
        (set! stack (rest stack))
        (while (stack-mark? top)
               ;; Skip stack marks.
               (set! found-stack-marks (cons top found-stack-marks))
               (set! top (first stack))
               (set! stack (rest stack)))
        ;; Return any stack marks to the stack and return.
        (for ([mark (in-list found-stack-marks)])
          (gs-push! mark))
        top)))

(define (gs-builtin? a-var)
  (hash-has-key? builtins a-var))

(define (gs-builtin! a-var)
  ((hash-ref builtins a-var)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Builtin golfscript functions. All are mutating because they pop args from the stack.
;;; It's not explicit in the tutorial, but args are ordered left to right, not
;;; in the order they are popped. So in a two argument function, the second argument
;;; is at the top of the stack.
(define (gs-+)
  (define second (gs-pop!))
  (gs-push! (+ (gs-pop!) second)))
(define (gs--)
  (define second (gs-pop!))
  (gs-push! (- (gs-pop!) second)))
(define (gs-*)
  (define second (gs-pop!))
  (gs-push! (* (gs-pop!) second)))

(hash-set! builtins "+" gs-+)
(hash-set! builtins "-" gs--)
(hash-set! builtins "*" gs-*)

(define (gs-~)
  (let ([arg (gs-pop!)])
    (cond
      [(number? arg) (gs-push! (bitwise-not arg))]
      [(string? arg) (eval (parse-to-datum (apply-tokenizer make-tokenizer arg))
                           gs-namespace)]
      [(procedure? arg) (arg)]
      [(list? arg) (for ([i (in-list arg)]) (gs-push! i))])))
