;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#lang br

(provide
 ;; Special macros
 (rename-out [golfscript-module-begin #%module-begin]
             [golfscript-top #%top])
 #%app #%datum #%top-interaction require

 ;; Global data
 gs-program-result

 ;; Core syntax
 gs-program gs-eval gs-var gs-string gs-block gs-block-repr gs-list gs-assignment
 gs-comment

 ;; Core functions
 gs-string-repr gs-display-stack gs-push! gs-pop! gs-val
 )

;;; Rquires for gs-~ definition.
(require "parser.rkt" "tokenizer.rkt")
(require brag/support)
(require racket/block racket/string racket/contract)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Type constants and contracts.
;; Type prority (low -> high)
;; integer -> array -> string -> block
;;
;; Types are represented as symbols of the same name
(struct gs-block-data (proc repr))
(define gs-integer? integer?)
(define gs-array? list?)
(define gs-string? string?)
(define gs-block? gs-block-data?)

(define type-priority-list '(integer array string block))
(define gs-value/c (or/c gs-integer? gs-array? gs-string? gs-block?))
(define gs-type/c (lambda (x) (member x type-priority-list)))


;;; Global data and data types.
(define gs-stack (make-parameter empty))
(define globals (make-hash))
(define builtins (make-hash))
(define undefined-var 'undefined)
(define gs-program-result (make-parameter ""))
(define gs-namespace (make-parameter (make-empty-namespace)))
(define-namespace-anchor gs-expander-ns)
(struct stack-mark (id))

;;; Module begin.
(define-macro (golfscript-module-begin PROGRAM)
  #'(#%module-begin
     (provide gs-program-result gs-stack)
     (define-namespace-anchor gs-runtime-ns)
     (parameterize ([current-namespace (namespace-anchor->namespace gs-runtime-ns)])
       PROGRAM)))

;;; Top
;; Alter top level undefined behavior. Ignore undefined variables.
(define-macro (golfscript-top . ID)
  (if (identifier-binding #'ID) #'ID #'(void)))

;;; Syntax
(define-macro (gs-program EXPR ...)
  ;; Vars are self-evaluating so all we need to do is display the stack.
  (syntax/loc caller-stx
    (block
     EXPR ...
     (displayln `("FINAL STACK" ,(gs-stack)))
     (gs-program-result (gs-display-stack)))))

(define-macro (gs-eval EXPR ...)
  (syntax/loc caller-stx
    (block EXPR ...)))

(define-macro (gs-var VAR)
  (syntax/loc caller-stx (gs-val VAR)))

(define-macro (gs-string STRING)
  (syntax/loc caller-stx (gs-push! gs-stack STRING)))

(define-macro-cases gs-block
  [(gs-block EXPR1 EXPRN ...)
   (syntax/loc caller-stx
     (gs-push! gs-stack
               (gs-block-data
                (lambda () EXPR1 EXPRN ...)
                (gs-block-repr (gs-block EXPR1 EXPRN ...)))))]
  [(gs-block)
   (syntax/loc caller-stx
     (gs-push! gs-stack
               (gs-block-data
                (lambda () (void))
                (gs-block-repr (gs-block)))))])

(define-macro-cases gs-block-repr
  [(gs-block-repr (gs-block EXPR ...))
   #`(string-append
      "{"
      (string-join (list (gs-block-repr EXPR) ...) "")
      "}")]
  [(gs-block-repr (HEAD ARG)) (gs-string-repr (syntax->datum #'ARG))])

(begin-for-syntax
  (require racket/string)
  (define (gs-string-repr arg)
    (cond
      ; No need to address procedures because gs-block-repr handles that.
      [(integer? arg) (number->string arg)]
      ; Check for list delimiters before strings, because they look like strings.
      [(or (equal? arg "[") (equal? arg "]")) arg]
      [(string? arg) (string-append "\"" arg "\"")]
      [(symbol? arg) (symbol->string arg)]
      [(list? arg) (string-append "[" (string-join (map gs-string-repr arg) " ") "]")])))

(define-macro-cases gs-list
  [(gs-list "[")
   ;; Mark stack position, and pop everything between it and top of stack.
   (syntax/loc caller-stx
     (gs-push! gs-stack (stack-mark (gensym))))]
  [(gs-list "]")
   ;; Pop until we reach a stack mark or stack is empty.
   (syntax/loc caller-stx
     (let ([top (gs-pop! gs-stack #:return-stack-mark? #t)]
           [return-list empty])
       (until (or (empty? (gs-stack)) (stack-mark? top))
              (set! return-list (cons top return-list))
              (set! top (gs-pop! gs-stack #:return-stack-mark? #t)))
       ;; If the last pop was a stack-mark ignore it, but if not, add it in.
       (when (not (stack-mark? top))
         (set! return-list (cons top return-list)))
       (gs-push! gs-stack return-list)))])

(define-macro (gs-assignment EXPR (gs-var VAR))
  (syntax/loc caller-stx
    (begin
      EXPR
      (define VAR (gs-peek gs-stack)))))

(define-macro (gs-comment COMMENT)
  #'(void))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Internal functions generated by syntax macros.
(define (gs-display-stack)
  ;Stack must be reversed to display with top on right.
  (gs-stack (reverse (gs-stack)))
  (define result
    (string-trim
     (with-output-to-string
       (λ () (for ([el (gs-stack)]) (gs-display el))))
     "\""))
  (displayln "RESULT")
  (displayln result)
  result)

(define (gs-display value)
  (cond
    [(gs-block? value)
     (display (gs-block-data-repr value))]
    [(gs-array? value)
     (display "[")
     (let loop ([to-show value])
       (cond
         [(empty? to-show) (display "]")]
         [else
          (gs-display (first to-show))
          (unless (empty? (rest to-show))
            (display " "))
          (loop (rest to-show))]))]
    [else (display value)]))

(define (stack-height) (length (gs-stack)))

(define (gs-push! a-stack value)
  (displayln `(gs-push! ,(a-stack) ,value))
  (a-stack (cons value (a-stack))))

(define (gs-pop! a-stack #:return-stack-mark? [return-stack-mark? #f])
  (if return-stack-mark?
      (let ([top (first (a-stack))])
        (a-stack (rest (a-stack)))
        top)
      (let ([top (first (a-stack))]
            [found-stack-marks empty])
        (a-stack (rest (a-stack)))
        (while (stack-mark? top)
               ;; Skip stack marks.
               (set! found-stack-marks (cons top found-stack-marks))
               (set! top (first (a-stack)))
               (a-stack (rest (a-stack))))
        ;; Return any stack marks to the stack and return.
        (for ([mark (in-list found-stack-marks)])
          (gs-push! a-stack mark))
        top)))

(define (gs-val a-var)
  (display "gs-val ")
  (displayln a-var)
  (cond
    [(gs-block? a-var) ((gs-block-data-proc a-var gs-stack))]
    [(procedure? a-var) (a-var gs-stack)]
    ;; Numbers have their literal value as their default value.
    [(gs-integer? a-var) (gs-push! gs-stack a-var)]
    ;; Undefined values are ignored. Otherwise we push the new vlaue to the stack.
    [(not (void? a-var)) (gs-push! gs-stack a-var)]
    ))


(define (gs-peek a-stack)
  (first (a-stack)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Type conversions
;;
;; Type prority (low -> high)
;; integer -> array -> string -> block
;;
;; Types are represented as symbols of the same name

;; Promote two arguments to highest common type
;; any::t1 any::t2 -> max(t1,t2) max(t1,t2)
(define (gs-promote arg1 arg2)
  (let ([type-arg1 (gs-type arg1)]
        [type-arg2 (gs-type arg2)])
    (let ([type-max (gs-type-max type-arg1 type-arg2)])
      (values (gs-convert type-max arg1)
              (gs-convert type-max arg2)))))

;; Return type of argument as symbol
;; One of '(integer array string block)
(provide
 (contract-out
  [gs-type (-> gs-value/c gs-type/c)]))
(define (gs-type arg)
  (cond
    [(gs-integer? arg) 'integer]
    [(gs-array? arg) 'array]
    [(gs-string? arg) 'string]
    [(gs-block? arg) 'block]))

;; Return higher priority type of its two arguments.
(provide
 (contract-out
  [gs-type-max (-> gs-type/c gs-type/c gs-type/c)]))
(define (gs-type-max type1 type2)
  (define (type-priority type)
    (index-of type-priority-list  type))
  (let ([type1-priority (type-priority type1)]
        [type2-priority (type-priority type2)])
    (list-ref type-priority-list (max type1-priority type2-priority))))

;; Convert argument up to type.
(provide
 (contract-out
  [gs-convert (-> gs-type/c gs-value/c gs-value/c)]))
(define (gs-convert type arg)
  (define arg-type (gs-type arg))
  (cond
    [(equal? arg-type 'integer (gs-convert-integer type arg))]
    [(equal? arg-type 'array (gs-convert-array type arg))]
    [(equal? arg-type 'string (gs-convert-string type arg))]
    ; Only block is left, and we never convert a block down, only up, so it
    ; passes through
    [else arg]))

; Convert integer up to specified type.
(provide
 (contract-out
  [gs-convert-integer (-> gs-type/c gs-integer? gs-value/c)]))
(define (gs-convert-integer type arg)
  (cond
    [(equal? type 'integer) arg]
    [(equal? type 'array) (list arg)]
    [(equal? type 'string) (number->string arg)]
    [(equal? type 'block) (gs-string->block (number->string arg))]))

; Convert array up to specified type.
(define (gs-convert-array type arg)
  (void))

; Convert string up to specified type, which can only be a block.
(define (gs-convert-string type arg)
  (void))

(define (gs-string->block str)
  (gs-block-data
   (lambda () (gs-eval-string str))
   (string-append "{" str "}")))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Builtin golfscript functions. All are mutating because they pop args from the stack.
;;; It's not explicit in the tutorial, but args are ordered left to right, not
;;; in the order they are popped. So in a two argument function, the second argument
;;; is at the top of the stack.

;; Builtins shadow base names, so rename on export.
(provide (rename-out [gs-tilde ~]
                     [gs-backtick |`|]
                     [gs-! !]
                     [gs-@ |@|]
                     [gs-$ $]
                     [gs-+ +]
                     [gs-- -]
                     [gs-* *]
                     ))

(define (gs-tilde gs-stack)
  (writeln "gs-tilde")
  (let ([arg (gs-pop! gs-stack)])
    (cond
      [(gs-integer? arg) (gs-push! gs-stack (bitwise-not arg))]
      [(gs-string? arg) (gs-eval-string arg)]
      [(gs-block? arg) ((gs-block-data-proc arg))]
      [(gs-array? arg) (for ([i (in-list arg)]) (gs-push! gs-stack i))])))

(define (gs-eval-string str)
  (eval `(gs-eval ,@(cdr (parse-to-datum (apply-tokenizer make-tokenizer str))))))
(define (gs-backtick gs-stack)
  (define arg (gs-pop! gs-stack))
  (define arg-repr
    (cond
      [(gs-block? arg) (gs-block-data-repr arg)]
      [else (gs-string-repr arg)]))
  (gs-push! gs-stack (gs-string-repr arg-repr)))

(define (gs-string-repr arg)
  (cond
    ; No need to address procedures because gs-backtick handles that.
    [(gs-integer? arg) (number->string arg)]
    ; Check for list delimiters before strings, because they look like strings.
    [(or (equal? arg "[") (equal? arg "]")) arg]
    [(gs-string? arg) (string-append "\"" arg "\"")]
    [(gs-array? arg) (string-append "["
                                    (string-join (map gs-string-repr arg) " ")
                                    "]")]))

(define (gs-! a-stack)
  (define arg (gs-pop! a-stack))
  (gs-push!
   a-stack
   (if
    (or (equal? arg 0)
        (equal? arg empty)
        (equal? arg "")
        (and (gs-block? arg) (equal? (gs-block-data-repr arg) "{}")))
    1
    0)))

(define (gs-@ a-stack)
  (define-values (arg3 arg2 arg1)
    (values (gs-pop! a-stack) (gs-pop! a-stack) (gs-pop! a-stack)))
  (gs-push! a-stack arg2)
  (gs-push! a-stack arg3)
  (gs-push! a-stack arg1))
  
(define (gs-- gs-stack)
  (define second (gs-pop! gs-stack))
  (gs-push! gs-stack (- (gs-pop! gs-stack) second)))
(define (gs-* gs-stack)
  (define second (gs-pop! gs-stack))
  (gs-push! gs-stack (* (gs-pop! gs-stack) second)))


(define (gs-$ a-stack)
  (define top (gs-peek a-stack))
  (cond
    ; list block or string block. Sort by block as key function.
    [(gs-block? top)
     (let-values ([(arg2 arg1) (values (gs-pop! a-stack) (gs-pop! a-stack))])
       (let* ([key-proc (gs-block-data-proc arg2)]
              [cmp (λ (x y) (gs-lt key-proc x y))])
         ; First arg must be a list.
         (gs-push! a-stack (sort arg1 cmp))))]
    ; string arg. Sort alphabetically
    ; integer. Index value off stack and copy to top.
    [(gs-string? top)
     (let ([arg (string->list (gs-pop! a-stack))])
       (gs-push! a-stack (list->string (sort arg char<?))))]
    [else (begin
            (define arg (gs-pop! a-stack))
            ; Golfscript zero indexes, so 0 is top of stack.
            ; For take, 1 is top of stack.
            (gs-push! a-stack (last (take (a-stack) (add1 arg)))))]))

(define (gs-lt key-func x y)
  (parameterize ([gs-stack empty])
    (gs-push! gs-stack x)
    (gs-push! gs-stack y)
    (key-func)
    (let ([fy (gs-pop! gs-stack)])
      (key-func)
      (let ([fx (gs-pop! gs-stack)])
        (fx . < . fy)))))

(define (gs-+ gs-stack)
  (define second (gs-pop! gs-stack))
  (define first (gs-pop! gs-stack))
  (println `(gs-+ ,first ,second))
  (gs-push! gs-stack (+ first second)))

(define (gs-list-append left right)
  (append* left right))

(define (gs-string-append left right)
  (string-append left right))

(define (gs-block-append left right)
  (define (block-body a-block)
    (let ([repr (gs-block-data-repr a-block)])
      (substring repr 1 (string-length repr))))
  (let ([left-body (block-body left)]
        [right-body (block-body right)])
    (gs-string->block (string-append left-body " " right-body))))
